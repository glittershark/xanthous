--------------------------------------------------------------------------------
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE DeriveFunctor #-}
{-# OPTIONS_GHC -fno-warn-orphans #-}
--------------------------------------------------------------------------------
module Xanthous.Random
  ( -- | Random Monad
    MonadRandom(..)
  , liftReader
  , uniformWord32R
  , uniformWord64R
  , uniformWord8
  , uniformR
  , RandomGen

    -- | Random generation
  , Choose(..)
  , ChooseElement(..)
  , Weighted(..)
  , evenlyWeighted
  , weightedBy
  -- , subRand
  , chance
  , chooseSubset
  , chooseRange
  , FiniteInterval(..)
  ) where
--------------------------------------------------------------------------------
import           Xanthous.Prelude
--------------------------------------------------------------------------------
import           Control.Monad.Trans (MonadTrans)
import           Data.List.NonEmpty (NonEmpty(..))
import           Data.Functor.Compose
import           Data.Random.Shuffle.Weighted
import           Data.Random.Distribution
import           Data.Random.Distribution.Uniform
import           Data.Random.Distribution.Uniform.Exclusive
import           Data.Random.Sample
import           Data.Interval ( Interval, lowerBound', Extended (Finite)
                               , upperBound', Boundary (Closed), lowerBound
                               , upperBound
                               )
import qualified System.Random.Stateful as RS
import           System.Random.Stateful (UniformRange, RandomGen(..))
import Control.Monad.ST
--------------------------------------------------------------------------------

class (Monad m, RS.StatefulGen (Generator m) m) => MonadRandom m where
  type Generator m
  getGen :: m (Generator m)

newtype RandST g s a = RandST { runRandSTT :: RS.STGenM g s -> (ST s) a }
  deriving stock Functor

instance RS.RandomGen g => MonadRandom (RandST g s) where
  type Generator (RandST g s) = RS.STGenM g s
  getGen = ask

instance (MonadTrans t, Monad (t m), MonadRandom m) => MonadRandom (t m) where
  type Generator (t m) = Generator m
  getGen = lift getGen

instance {-# INCOHERENT #-} (MonadTrans t, Monad (t m), RS.StatefulGen g m) => RS.StatefulGen g (t m) where
  uniformWord32R u g = lift $ RS.uniformWord32R u g
  uniformWord64R u g = lift $ RS.uniformWord64R u g
  uniformWord8 g = lift $ RS.uniformWord8 g
  uniformWord16 g = lift $ RS.uniformWord16 g
  uniformWord32 g = lift $ RS.uniformWord32 g
  uniformWord64 g = lift $ RS.uniformWord64 g
  uniformShortByteString l g = lift $ RS.uniformShortByteString l g

liftReader :: MonadRandom m => ReaderT (Generator m) m a -> m a
liftReader x = do
  gen <- getGen
  runReaderT x gen

uniformWord32R :: MonadRandom m => Word32 -> m Word32
uniformWord32R ub = getGen >>= RS.uniformWord32R ub

uniformWord64R :: MonadRandom m => Word64 -> m Word64
uniformWord64R ub = getGen >>= RS.uniformWord64R ub

uniformWord8 :: MonadRandom m => m Word8
uniformWord8 = getGen >>= RS.uniformWord8

uniformR :: (UniformRange a, MonadRandom m) => (a, a) -> m a
uniformR range = getGen >>= RS.uniformRM range

class Choose a where
  type RandomResult a
  choose :: MonadRandom m => a -> m (RandomResult a)

newtype ChooseElement a = ChooseElement a

instance MonoFoldable a => Choose (ChooseElement a) where
  type RandomResult (ChooseElement a) = Maybe (Element a)
  choose (ChooseElement xs) = do
    chosenIdx <- uniformR (0, olength xs - 1)
    let pick _ (Just x) = Just x
        pick (x, i) Nothing
          | i == chosenIdx = Just x
          | otherwise = Nothing
    pure $ ofoldr pick Nothing $ zip (toList xs) [0..]

instance MonoFoldable a => Choose (NonNull a) where
  type RandomResult (NonNull a) = Element a
  choose
    = fmap (fromMaybe (error "unreachable")) -- why not lol
    . choose
    . ChooseElement
    . toNullable

instance Choose (NonEmpty a) where
  type RandomResult (NonEmpty a) = a
  choose = choose . fromNonEmpty @[_]

instance Choose (a, a) where
  type RandomResult (a, a) = a
  choose (x, y) = choose (x :| [y])

newtype Weighted w t a = Weighted (t (w, a))
  deriving (Functor, Foldable) via (t `Compose` (,) w)

deriving newtype instance Eq (t (w, a)) => Eq (Weighted w t a)
deriving newtype instance Show (t (w, a)) => Show (Weighted w t a)
deriving newtype instance NFData (t (w, a)) => NFData (Weighted w t a)

instance Traversable t => Traversable (Weighted w t) where
  traverse f (Weighted twa) = Weighted <$> (traverse . traverse) f twa

evenlyWeighted :: [a] -> Weighted Int [] a
evenlyWeighted = Weighted . itoList

-- | Weight the elements of some functor by a function. Larger values of 'w' per
-- its 'Ord' instance will be more likely to be generated
weightedBy :: Functor t => (a -> w) -> t a -> Weighted w t a
weightedBy weighting xs = Weighted $ (weighting &&& id) <$> xs

instance (Num w, Ord w, Distribution Uniform w, Excludable w)
       => Choose (Weighted w [] a) where
  type RandomResult (Weighted w [] a) = Maybe a
  choose (Weighted ws) = liftReader $ sample $ headMay <$> weightedSample 1 ws

instance (Num w, Ord w, Distribution Uniform w, Excludable w)
       => Choose (Weighted w NonEmpty a) where
  type RandomResult (Weighted w NonEmpty a) = a
  choose (Weighted ws) =
    liftReader
    $ sample
    $ fromMaybe (error "unreachable") . headMay
    <$> weightedSample 1 (toList ws)

-- TODO: ???
-- subRand :: MonadRandom m => Rand StdGen a -> m a
-- subRand sub = evalRand sub . mkStdGen <$> getRandom

-- | Has a @n@ chance of returning 'True'
--
-- eg, chance 0.5 will return 'True' half the time
chance
  :: (Num w, Ord w, Distribution Uniform w, Excludable w, MonadRandom m)
  => w
  -> m Bool
chance n = choose $ weightedBy (bool 1 (n * 2)) bools

-- | Choose a random subset of *about* @w@ of the elements of the given
-- 'Witherable' structure
chooseSubset :: ( Num w, Ord w, Distribution Uniform w, Excludable w
               , Witherable t
               , MonadRandom m
               ) => w -> t a -> m (t a)
chooseSubset = filterA . const . chance

-- | Choose a random @n@ in the given interval
chooseRange
  :: ( MonadRandom m
    , Distribution Uniform n
    , Enum n
    , Bounded n
    , Ord n
    )
  => Interval n
  -> m (Maybe n)
chooseRange int = traverse (liftReader . sample) distribution
  where
    (lower, lowerBoundary) = lowerBound' int
    lowerR = case lower of
      Finite x -> if lowerBoundary == Closed
                 then x
                 else succ x
      _ -> minBound
    (upper, upperBoundary) = upperBound' int
    upperR = case upper of
      Finite x -> if upperBoundary == Closed
                 then x
                 else pred x
      _ -> maxBound
    distribution
      | lowerR <= upperR = Just $ Uniform lowerR upperR
      | otherwise = Nothing

instance ( Distribution Uniform n
         , Enum n
         , Bounded n
         , Ord n
         )
         => Choose (Interval n) where
  type RandomResult (Interval n) = n
  choose = fmap (fromMaybe $ error "Invalid interval") . chooseRange

newtype FiniteInterval a
  = FiniteInterval { unwrapFiniteInterval :: Interval a }

instance ( Distribution Uniform n
         , Ord n
         )
         => Choose (FiniteInterval n) where
  type RandomResult (FiniteInterval n) = n
  -- TODO broken with open/closed right now
  choose
    = liftReader
    . sample
    . uncurry Uniform
    . over both getFinite
    . (lowerBound &&& upperBound)
    . unwrapFiniteInterval
    where
      getFinite (Finite x) = x
      getFinite _ = error "Infinite value"

--------------------------------------------------------------------------------

bools :: NonEmpty Bool
bools = True :| [False]
